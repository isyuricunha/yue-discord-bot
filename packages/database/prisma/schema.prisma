generator client {
  provider   = "prisma-client-js"
  engineType = "library"
}

datasource db {
  provider = "postgresql"
}

model Guild {
  id                          String                       @id
  name                        String
  icon                        String?
  ownerId                     String
  addedAt                     DateTime                     @default(now())
  aniListNotificationChannels AniListNotificationChannel[]
  auditLogs                   AuditLog[]
  giveaways                   Giveaway[]
  autoroleConfig              GuildAutoroleConfig?
  autorolePendings            GuildAutorolePending[]
  autoroleRoles               GuildAutoroleRole[]
  commandOverrides            GuildCommandOverride[]
  config                      GuildConfig?
  levelRoleRewards            GuildLevelRoleReward[]
  members                     GuildMember[]
  xpConfig                    GuildXpConfig?
  xpMembers                   GuildXpMember[]
  inventoryItems              InventoryItem[]
  modLogs                     ModLog[]
  purchases                   Purchase[]
  reactionRolePanels          ReactionRolePanel[]
  scheduledEvents             ScheduledEvent[]
  shopItems                   ShopItem[]
  starboardConfig             StarboardConfig?
  starboardPosts              StarboardPost[]
  suggestionConfig            SuggestionConfig?
  suggestions                 Suggestion[]
  ticketConfig                TicketConfig?
  tickets                     Ticket[]
  waifuClaims                 WaifuClaim[]
  waifuRolls                  WaifuRoll[]
  waifuUserStates             WaifuUserState[]
  waifuWishlists              WaifuWishlist[]

  @@map("guilds")
}

model GuildConfig {
  id                          String   @id @default(cuid())
  guildId                     String   @unique
  modLogChannelId             String?
  giveawayChannelId           String?
  welcomeChannelId            String?
  muteRoleId                  String?
  bannedWords                 Json     @default("[]")
  wordFilterEnabled           Boolean  @default(false)
  wordFilterWhitelistChannels Json     @default("[]")
  wordFilterWhitelistRoles    Json     @default("[]")
  capsEnabled                 Boolean  @default(false)
  capsThreshold               Int      @default(70)
  capsMinLength               Int      @default(10)
  capsAction                  String   @default("warn")
  capsWhitelistChannels       Json     @default("[]")
  capsWhitelistRoles          Json     @default("[]")
  linkFilterEnabled           Boolean  @default(false)
  linkBlockAll                Boolean  @default(false)
  bannedDomains               Json     @default("[]")
  allowedDomains              Json     @default("[]")
  linkAction                  String   @default("delete")
  linkWhitelistChannels       Json     @default("[]")
  linkWhitelistRoles          Json     @default("[]")
  warnThresholds              Json     @default("[]")
  warnExpiration              Int      @default(30)
  locale                      String   @default("pt-BR")
  timezone                    String   @default("America/Sao_Paulo")
  prefix                      String   @default("/")
  updatedAt                   DateTime @updatedAt
  leaveChannelId              String?
  leaveMessage                String?
  welcomeMessage              String?
  modLogMessage               String?
  announcementChannelId       String?
  guild                       Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@map("guild_configs")
}

model GuildCommandOverride {
  id          String           @id @default(cuid())
  guildId     String
  commandType GuildCommandType
  commandName String
  enabled     Boolean          @default(true)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  guild       Guild            @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@unique([guildId, commandType, commandName])
  @@index([guildId])
  @@map("guild_command_overrides")
}

model GuildMember {
  id       String   @id @default(cuid())
  userId   String
  guildId  String
  username String
  avatar   String?
  joinedAt DateTime
  warnings Int      @default(0)
  notes    String?
  guild    Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)
  modLogs  ModLog[]

  @@unique([userId, guildId])
  @@map("guild_members")
}

model ModLog {
  id          String      @id @default(cuid())
  guildId     String
  userId      String
  moderatorId String
  action      String
  reason      String?
  duration    String?
  metadata    Json?
  createdAt   DateTime    @default(now())
  guild       Guild       @relation(fields: [guildId], references: [id], onDelete: Cascade)
  member      GuildMember @relation(fields: [userId, guildId], references: [userId, guildId], onDelete: Cascade)

  @@index([guildId, createdAt])
  @@index([userId])
  @@map("mod_logs")
}

model AuditLog {
  id              String   @id @default(cuid())
  guildId         String
  action          String
  actorUserId     String?
  targetUserId    String?
  targetChannelId String?
  targetMessageId String?
  data            Json?
  createdAt       DateTime @default(now())
  guild           Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@index([guildId, createdAt])
  @@index([guildId, action, createdAt])
  @@index([guildId, actorUserId, createdAt])
  @@index([guildId, targetUserId, createdAt])
  @@index([guildId, targetChannelId, createdAt])
  @@map("audit_logs")
}

model Giveaway {
  id              String           @id @default(cuid())
  guildId         String
  title           String
  description     String
  channelId       String
  messageId       String?
  creatorId       String
  requiredRoleId  String?
  emojiId         String?          @default("üéâ")
  maxWinners      Int
  format          String           @default("reaction")
  availableItems  Json?
  minChoices      Int?
  maxChoices      Int?
  startsAt        DateTime?
  endsAt          DateTime
  ended           Boolean          @default(false)
  cancelled       Boolean          @default(false)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  requiredRoleIds Json?
  suspended       Boolean          @default(false)
  roleChances     Json?
  entries         GiveawayEntry[]
  winners         GiveawayWinner[]
  entryEditTokens GiveawayEntryEditToken[]
  guild           Guild            @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@index([guildId, ended])
  @@map("giveaways")
}

model GiveawayEntry {
  id           String   @id @default(cuid())
  giveawayId   String
  userId       String
  username     String
  avatar       String?
  choices      Json?
  disqualified Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  giveaway     Giveaway @relation(fields: [giveawayId], references: [id], onDelete: Cascade)

  @@unique([giveawayId, userId])
  @@index([giveawayId])
  @@map("giveaway_entries")
}

model GiveawayWinner {
  id         String   @id @default(cuid())
  giveawayId String
  userId     String
  username   String
  prize      String?
  prizeIndex Int?
  notified   Boolean  @default(false)
  createdAt  DateTime @default(now())
  giveaway   Giveaway @relation(fields: [giveawayId], references: [id], onDelete: Cascade)

  @@index([giveawayId])
  @@map("giveaway_winners")
}

model GiveawayEntryEditToken {
  id         String   @id @default(cuid())
  giveawayId String
  userId     String
  token      String   @unique
  expiresAt  DateTime
  usedAt     DateTime?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  giveaway   Giveaway @relation(fields: [giveawayId], references: [id], onDelete: Cascade)

  @@unique([giveawayId, userId])
  @@index([expiresAt])
  @@index([usedAt])
  @@index([giveawayId])
  @@map("giveaway_entry_edit_tokens")
}

model ScheduledEvent {
  id              String    @id @default(cuid())
  guildId         String
  channelId       String
  creatorId       String
  title           String
  description     String?
  startsAt        DateTime
  ended           Boolean   @default(false)
  cancelled       Boolean   @default(false)
  reminder24hSent Boolean   @default(false)
  reminder1hSent  Boolean   @default(false)
  reminder10mSent Boolean   @default(false)
  reminder24hAt   DateTime?
  reminder1hAt    DateTime?
  reminder10mAt   DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  guild           Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@index([guildId, startsAt])
  @@index([guildId, ended, cancelled, startsAt])
  @@map("scheduled_events")
}

model OwnerActionLog {
  id          String    @id @default(cuid())
  actorUserId String
  type        String
  status      String
  request     Json
  preview     Json?
  result      Json?
  createdAt   DateTime  @default(now())
  executedAt  DateTime?

  @@index([type, createdAt])
  @@index([status, createdAt])
  @@map("owner_action_logs")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@map("sessions")
}

model GuildXpConfig {
  id                String   @id @default(cuid())
  guildId           String   @unique
  enabled           Boolean  @default(true)
  minMessageLength  Int      @default(5)
  minUniqueLength   Int      @default(12)
  typingCps         Int      @default(7)
  xpDivisorMin      Int      @default(7)
  xpDivisorMax      Int      @default(4)
  xpCap             Int      @default(35)
  ignoredChannelIds Json     @default("[]")
  ignoredRoleIds    Json     @default("[]")
  roleXpMultipliers Json     @default("{}")
  rewardMode        String   @default("stack")
  levelUpChannelId  String?
  levelUpMessage    String?
  updatedAt         DateTime @updatedAt
  guild             Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@map("guild_xp_configs")
}

model GuildXpMember {
  id              String    @id @default(cuid())
  userId          String
  guildId         String
  xp              Int       @default(0)
  level           Int       @default(0)
  lastMessageHash String?
  lastMessageAt   DateTime?
  updatedAt       DateTime  @updatedAt
  guild           Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@unique([userId, guildId])
  @@index([guildId, xp])
  @@map("guild_xp_members")
}

model GuildLevelRoleReward {
  id      String @id @default(cuid())
  guildId String
  level   Int
  roleId  String
  guild   Guild  @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@unique([guildId, level])
  @@index([guildId, level])
  @@map("guild_level_role_rewards")
}

model GlobalXpMember {
  userId          String    @id
  username        String
  avatar          String?
  xp              Int       @default(0)
  level           Int       @default(0)
  lastMessageHash String?
  lastMessageAt   DateTime?
  updatedAt       DateTime  @updatedAt

  @@index([xp])
  @@map("global_xp_members")
}

model GuildAutoroleConfig {
  id                    String              @id @default(cuid())
  guildId               String              @unique
  enabled               Boolean             @default(false)
  delaySeconds          Int                 @default(0)
  onlyAfterFirstMessage Boolean             @default(false)
  updatedAt             DateTime            @updatedAt
  guild                 Guild               @relation(fields: [guildId], references: [id], onDelete: Cascade)
  roles                 GuildAutoroleRole[] @relation("guild_autorole_config_roles")

  @@map("guild_autorole_configs")
}

model GuildAutoroleRole {
  id       String              @id @default(cuid())
  configId String
  guildId  String
  roleId   String
  config   GuildAutoroleConfig @relation("guild_autorole_config_roles", fields: [configId], references: [id], onDelete: Cascade)
  guild    Guild               @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@unique([guildId, roleId])
  @@index([configId])
  @@index([guildId])
  @@map("guild_autorole_roles")
}

model GuildAutorolePending {
  id                  String    @id @default(cuid())
  guildId             String
  userId              String
  waitForFirstMessage Boolean   @default(false)
  executeAt           DateTime?
  attempts            Int       @default(0)
  lastError           String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  guild               Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@unique([guildId, userId])
  @@index([guildId, executeAt])
  @@map("guild_autorole_pendings")
}

model TicketConfig {
  id             String   @id @default(cuid())
  guildId        String   @unique
  enabled        Boolean  @default(false)
  categoryId     String?
  logChannelId   String?
  supportRoleIds Json     @default("[]")
  panelChannelId String?
  panelMessageId String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  guild          Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@map("ticket_configs")
}

model Ticket {
  id             String    @id @default(cuid())
  guildId        String
  userId         String
  channelId      String    @unique
  status         String    @default("open")
  closedAt       DateTime?
  closedByUserId String?
  closeReason    String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  guild          Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@index([guildId, status, createdAt])
  @@index([guildId, userId, createdAt])
  @@map("tickets")
}

model SuggestionConfig {
  id           String   @id @default(cuid())
  guildId      String   @unique
  enabled      Boolean  @default(false)
  channelId    String?
  logChannelId String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  guild        Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@map("suggestion_configs")
}

model Suggestion {
  id              String           @id @default(cuid())
  guildId         String
  userId          String
  sourceChannelId String
  sourceMessageId String
  messageId       String           @unique
  content         String
  status          String           @default("pending")
  upvotes         Int              @default(0)
  downvotes       Int              @default(0)
  decidedAt       DateTime?
  decidedByUserId String?
  decisionNote    String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  votes           SuggestionVote[]
  guild           Guild            @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@unique([guildId, sourceMessageId])
  @@index([guildId, status, createdAt])
  @@index([guildId, userId, createdAt])
  @@map("suggestions")
}

model SuggestionVote {
  id           String     @id @default(cuid())
  suggestionId String
  userId       String
  vote         String
  createdAt    DateTime   @default(now())
  suggestion   Suggestion @relation(fields: [suggestionId], references: [id], onDelete: Cascade)

  @@unique([suggestionId, userId])
  @@index([suggestionId])
  @@index([userId])
  @@map("suggestion_votes")
}

model ReactionRolePanel {
  id        String             @id @default(cuid())
  guildId   String
  name      String
  enabled   Boolean            @default(true)
  mode      String             @default("multiple")
  channelId String?
  messageId String?
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
  items     ReactionRoleItem[]
  guild     Guild              @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@index([guildId, createdAt])
  @@map("reaction_role_panels")
}

model ReactionRoleItem {
  id        String            @id @default(cuid())
  panelId   String
  roleId    String
  label     String?
  emoji     String?
  createdAt DateTime          @default(now())
  panel     ReactionRolePanel @relation(fields: [panelId], references: [id], onDelete: Cascade)

  @@unique([panelId, roleId])
  @@index([panelId])
  @@map("reaction_role_items")
}

model StarboardConfig {
  id         String   @id @default(cuid())
  guildId    String   @unique
  enabled    Boolean  @default(false)
  channelId  String?
  emoji      String   @default("‚≠ê")
  threshold  Int      @default(3)
  ignoreBots Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  guild      Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@map("starboard_configs")
}

model StarboardPost {
  id                 String   @id @default(cuid())
  guildId            String
  sourceChannelId    String
  sourceMessageId    String
  starboardChannelId String
  starboardMessageId String   @unique
  authorId           String
  starCount          Int      @default(0)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  guild              Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@unique([guildId, sourceMessageId])
  @@index([guildId, createdAt])
  @@index([guildId, starCount])
  @@map("starboard_posts")
}

model User {
  id                           String                       @id
  username                     String?
  avatar                       String?
  createdAt                    DateTime                     @default(now())
  updatedAt                    DateTime                     @updatedAt
  aniListNotificationChannels  AniListNotificationChannel[]
  aniListNotificationSettings  AniListNotificationSettings?
  aniListWatchlistItems        AniListWatchlistItem[]
  coinflipChallenges           CoinflipGame[]               @relation("coinflip_challenger")
  coinflipOpponents            CoinflipGame[]               @relation("coinflip_opponent")
  coinflipWins                 CoinflipGame[]               @relation("coinflip_winner")
  fanArts                      FanArt[]
  inventoryItems               InventoryItem[]
  luazinhaTransactionsSent     LuazinhaTransaction[]        @relation("luazinha_transactions_sent")
  luazinhaTransactionsReceived LuazinhaTransaction[]        @relation("luazinha_transactions_received")
  purchases                    Purchase[]
  badges                       UserBadge[]
  profile                      UserProfile?
  waifuClaims                  WaifuClaim[]
  waifuClaimsMade              WaifuRoll[]                  @relation("waifu_rolls_claimed_by")
  waifuRolls                   WaifuRoll[]                  @relation("waifu_rolls_rolled_by")
  waifuUserStates              WaifuUserState[]
  waifuWishlists               WaifuWishlist[]
  wallet                       Wallet?

  @@map("users")
}

model AniListWatchlistItem {
  id                   String           @id @default(cuid())
  userId               String
  mediaId              Int
  mediaType            AniListMediaType
  title                String
  siteUrl              String?
  imageUrl             String?
  enabled              Boolean          @default(true)
  nextAiringAt         Int?
  nextAiringEpisode    Int?
  lastNotifiedAiringAt Int?
  lastCheckedAt        DateTime?
  nextCheckAt          DateTime         @default(now())
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  user                 User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, mediaType, mediaId])
  @@index([mediaType, enabled, nextCheckAt])
  @@index([userId, mediaType, createdAt])
  @@map("anilist_watchlist_items")
}

model AniListNotificationSettings {
  userId    String   @id
  dmEnabled Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("anilist_notification_settings")
}

model AniListNotificationChannel {
  id        String   @id @default(cuid())
  userId    String
  guildId   String
  channelId String
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  guild     Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, guildId])
  @@index([guildId])
  @@index([userId])
  @@map("anilist_notification_channels")
}

model Wallet {
  userId    String   @id
  balance   BigInt   @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("wallets")
}

model LuazinhaTransaction {
  id         String   @id @default(cuid())
  type       String
  amount     BigInt
  fromUserId String?
  toUserId   String?
  guildId    String?
  reason     String?
  metadata   Json?
  createdAt  DateTime @default(now())
  fromUser   User?    @relation("luazinha_transactions_sent", fields: [fromUserId], references: [id])
  toUser     User?    @relation("luazinha_transactions_received", fields: [toUserId], references: [id])

  @@index([type, createdAt])
  @@index([fromUserId, createdAt])
  @@index([toUserId, createdAt])
  @@map("luazinha_transactions")
}

model ShopItem {
  id             String          @id @default(cuid())
  guildId        String?
  name           String
  description    String?
  kind           String
  price          BigInt
  enabled        Boolean         @default(true)
  stackable      Boolean         @default(true)
  metadata       Json?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  inventoryItems InventoryItem[]
  purchases      Purchase[]
  guild          Guild?          @relation(fields: [guildId], references: [id], onDelete: Cascade)

  @@index([guildId, enabled])
  @@map("shop_items")
}

model Purchase {
  id             String          @id @default(cuid())
  userId         String
  guildId        String?
  shopItemId     String
  quantity       Int             @default(1)
  total          BigInt
  createdAt      DateTime        @default(now())
  inventoryItems InventoryItem[]
  guild          Guild?          @relation(fields: [guildId], references: [id], onDelete: Cascade)
  shopItem       ShopItem        @relation(fields: [shopItemId], references: [id], onDelete: Cascade)
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([guildId, createdAt])
  @@map("purchases")
}

model InventoryItem {
  id               String    @id @default(cuid())
  userId           String
  guildId          String?
  purchaseId       String?
  shopItemId       String?
  kind             String
  title            String
  description      String?
  quantity         Int       @default(1)
  usedQuantity     Int       @default(0)
  metadata         Json?
  activatedAt      DateTime?
  expiresAt        DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  expiredHandledAt DateTime?
  guild            Guild?    @relation(fields: [guildId], references: [id], onDelete: Cascade)
  purchase         Purchase? @relation(fields: [purchaseId], references: [id])
  shopItem         ShopItem? @relation(fields: [shopItemId], references: [id])
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([userId, guildId, kind, expiresAt])
  @@map("inventory_items")
}

model CoinflipGame {
  id             String    @id @default(cuid())
  status         String    @default("pending")
  guildId        String?
  channelId      String?
  messageId      String?
  challengerId   String
  opponentId     String
  betAmount      BigInt
  challengerSide String
  winnerId       String?
  resultSide     String?
  createdAt      DateTime  @default(now())
  resolvedAt     DateTime?
  serverSeed     String?
  serverSeedHash String?
  challenger     User      @relation("coinflip_challenger", fields: [challengerId], references: [id], onDelete: Cascade)
  opponent       User      @relation("coinflip_opponent", fields: [opponentId], references: [id], onDelete: Cascade)
  winner         User?     @relation("coinflip_winner", fields: [winnerId], references: [id])

  @@index([status, createdAt])
  @@index([challengerId, createdAt])
  @@index([opponentId, createdAt])
  @@index([winnerId, createdAt])
  @@map("coinflip_games")
}

model UserProfile {
  id        String   @id @default(cuid())
  userId    String   @unique
  bio       String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model BotSettings {
  id              String   @id
  presenceEnabled Boolean  @default(false)
  presenceStatus  String   @default("online")
  activityType    String?
  activityName    String?
  activityUrl     String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  appDescription  String?

  @@map("bot_settings")
}

model Badge {
  id          String      @id
  name        String
  description String?
  category    String
  icon        String?
  hidden      Boolean     @default(false)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  users       UserBadge[]

  @@index([category])
  @@map("badges")
}

model UserBadge {
  id        String    @id @default(cuid())
  userId    String
  badgeId   String
  source    String
  grantedAt DateTime  @default(now())
  expiresAt DateTime?
  metadata  Json?
  badge     Badge     @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
  @@index([badgeId])
  @@index([userId])
  @@index([expiresAt])
  @@map("user_badges")
}

model FanArt {
  id               String    @id @default(cuid())
  userId           String
  status           String    @default("pending")
  sourceChannelId  String?
  sourceMessageId  String?
  imageUrl         String
  imageName        String?
  imageSize        Int?
  title            String?
  description      String?
  tags             Json?
  reviewedByUserId String?
  reviewedAt       DateTime?
  reviewNote       String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([userId, createdAt])
  @@map("fan_arts")
}

model WaifuCharacter {
  id         String          @id @default(cuid())
  source     String
  sourceId   Int
  name       String
  nameNative String?
  imageUrl   String
  gender     String?
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  favourites Int?
  value      Int?
  claims     WaifuClaim[]
  rolls      WaifuRoll[]
  wishlists  WaifuWishlist[]

  @@unique([source, sourceId])
  @@index([name])
  @@index([value])
  @@map("waifu_characters")
}

model WaifuClaim {
  id           String         @id @default(cuid())
  guildId      String
  userId       String
  characterId  String
  claimedAt    DateTime       @default(now())
  valueAtClaim Int            @default(0)
  character    WaifuCharacter @relation(fields: [characterId], references: [id], onDelete: Cascade)
  guild        Guild          @relation(fields: [guildId], references: [id], onDelete: Cascade)
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([guildId, characterId])
  @@index([guildId, userId, claimedAt])
  @@index([userId, claimedAt])
  @@map("waifu_claims")
}

model WaifuRoll {
  id              String         @id @default(cuid())
  guildId         String
  channelId       String
  messageId       String?        @unique
  rolledByUserId  String
  characterId     String
  expiresAt       DateTime
  claimedByUserId String?
  claimedAt       DateTime?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  kind            String
  desiredGender   String?
  character       WaifuCharacter @relation(fields: [characterId], references: [id], onDelete: Cascade)
  claimedByUser   User?          @relation("waifu_rolls_claimed_by", fields: [claimedByUserId], references: [id])
  guild           Guild          @relation(fields: [guildId], references: [id], onDelete: Cascade)
  rolledByUser    User           @relation("waifu_rolls_rolled_by", fields: [rolledByUserId], references: [id], onDelete: Cascade)

  @@index([guildId, rolledByUserId, createdAt])
  @@index([guildId, expiresAt])
  @@map("waifu_rolls")
}

model WaifuUserState {
  id                  String    @id @default(cuid())
  guildId             String
  userId              String
  nextClaimAt         DateTime?
  updatedAt           DateTime  @updatedAt
  nextRerollAt        DateTime?
  rollWindowStartedAt DateTime?
  rollUses            Int       @default(0)
  totalValue          Int       @default(0)
  guild               Guild     @relation(fields: [guildId], references: [id], onDelete: Cascade)
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([guildId, userId])
  @@index([guildId, nextClaimAt])
  @@index([guildId, nextRerollAt])
  @@index([guildId, userId, rollWindowStartedAt])
  @@index([guildId, totalValue])
  @@map("waifu_user_states")
}

model WaifuWishlist {
  id          String         @id @default(cuid())
  guildId     String
  userId      String
  characterId String
  createdAt   DateTime       @default(now())
  character   WaifuCharacter @relation(fields: [characterId], references: [id], onDelete: Cascade)
  guild       Guild          @relation(fields: [guildId], references: [id], onDelete: Cascade)
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([guildId, userId, characterId])
  @@index([guildId, userId, createdAt])
  @@index([guildId, characterId])
  @@map("waifu_wishlists")
}

enum GuildCommandType {
  slash
  context
}

enum AniListMediaType {
  anime
  manga
}
